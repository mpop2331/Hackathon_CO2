const fs = require('fs')
const path = require('path')

const { packArchiveCLI, unpackArchiveCLI } = require('./tar')
const { exists } = require('./utils')

const TEMP_DIR = fs.realpathSync(require('os').tmpdir())

const packTarArchive = async (files, root, flat = false) => {
  if (typeof files === 'string') return await packArchiveCLI(files)

  let tgzBuffer, temp
  try {
    temp = await fs.promises.mkdtemp(`${TEMP_DIR}${path.sep}tar-`)
    for (const file of files) {
      const fname = flat ? path.basename(file) : path.relative(root, file)
      const destination = path.join(temp, fname)
      const dirname = path.dirname(destination)
      if (!await exists(dirname)) await fs.promises.mkdir(dirname, { recursive: true })
      await fs.promises.copyFile(file, destination)
    }

    tgzBuffer = await packArchiveCLI(temp)
  } finally {
    if (await exists(temp)) {
      await fs.promises.rm(temp, { recursive: true, force: true })
    }
  }

  return tgzBuffer
}

const unpackTarArchive = async (buffer, folder) => {
  const temp = await fs.promises.mkdtemp(`${TEMP_DIR}${path.sep}tar-`)
  const tgz = path.join(temp, 'resources.tgz')
  await fs.promises.writeFile(tgz, Buffer.from(buffer), 'binary')

  try {
    await unpackArchiveCLI(tgz, folder)
  } finally {
    if (await exists(temp)) await fs.promises.rm(temp, { recursive: true, force: true })
  }
}

module.exports = {
  packTarArchive,
  unpackTarArchive
}
