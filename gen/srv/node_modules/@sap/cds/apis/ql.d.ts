import {Definition} from "./csn"
import * as CQN from "./cqn"

export type Query = CQN.Query

export class ConstructedQuery {
	then(_resolved:(x:any)=>any, _rejected:(e:Error)=>any) : any
}

interface Constructable<T> {
	new(...args: any[]): T
}

export class cds_ql {
	ql:QL & ((context:object) => QL)
}

export type PK = number | string | object

// to support path expressions: https://pages.github.tools.sap/cap/docs/java/query-api#path-expressions
// `Book.title` == `Proxy<Book>.title()`
type Proxy<T> = {
	[Key in keyof T]: () => Proxy<T[Key]>
} & {
	/**
	 * Accesses any nested attribute based on a path:
	 * `X.get('a.b.c.d')`. Note that you will not receive
	 * proper typing after this call.
	 * To still have access to typed results, use
	 * `X.a().b().c().d()` instead.
	 */
	get: (path: string) => Proxy<unknown>
}

// any class (not value) of array to represent plural types used in cds-typer.
// Mainly used as pattern match for SingularType
type ArrayClass = {new():Array<unknown>}

// concrete singular type.
// `SingularType<typeof Books>` == `Book`.
type SingularType<T extends ArrayClass> = InstanceType<T>[number]

declare class QL {
	SELECT : typeof SELECT & ((...columns:string[]) => SELECT<any>) & ((columns:string[]) => SELECT<any>)
	INSERT : typeof INSERT & ((...entries:object[]) => INSERT<any>) & ((entries:object[]) => INSERT<any>)
	UPDATE : typeof UPDATE & typeof UPDATE.entity
	DELETE : typeof DELETE
	CREATE : typeof CREATE
	DROP : typeof DROP
}

// (new QL).SELECT.from('Foo').byKey(11).a



export class SELECT<T> extends ConstructedQuery {
	static one : SELECT_one & { from: SELECT_one }
	static distinct : typeof SELECT
  static from : SELECT_from
	from (entity: Definition | string, primaryKey? : PK, projection? : (e:any)=>void) : this
	byKey (primaryKey? : PK) : this
	columns (projection:(e:T)=>void) : this
	columns (...col:string[]) : this
	where (predicate:object) : this
	where (...expr : any[]) : this
	and (predicate:object) : this
	and (...expr : any[]) : this
	having (...expr : string[]) : this
	having (predicate:object) : this
	groupBy (...expr : string[]) : this
	orderBy (...expr : string[]) : this
	limit (rows : number, offset? : number) : this
	forSharedLock () : this
	forUpdate () : this
	SELECT : CQN.SELECT
}

type SELECT_one =
((entity: Definition | string, primaryKey? : PK, projection? : (e:any)=>void) => SELECT<any>)

// calling with class
&   (<T extends ArrayClass>
	(entityType: T)
	=> SELECT<SingularType<T>> & Promise<SingularType<T>>)
&
	(<T extends ArrayClass>
	(entityType: T, projection: (e: Proxy<SingularType<T>>) => void)
	=> SELECT<SingularType<T>> & Promise<SingularType<T>>)
&
	(<T extends ArrayClass>
	(entityType: T, primaryKey : PK, projection: (e: Proxy<SingularType<T>>) => void)
	=> SELECT<SingularType<T>> & Promise<SingularType<T>>)


& (<T> (entity: T[], projection? : (e:T)=>void) => SELECT<T> & Promise<T>)
& (<T> (entity: T[], primaryKey : PK, projection? : (e:T)=>void) => SELECT<T> & Promise<T>)
& (<T> (entity: {new():T}, projection? : (e:T)=>void) => SELECT<T> & Promise<T>)
& (<T> (entity: {new():T}, primaryKey : PK, projection? : (e:T)=>void) => SELECT<T> & Promise<T>)



type SELECT_from =
// calling with class
	(<T extends ArrayClass>
	(entityType: T)
	=> SELECT<SingularType<T>> & Promise<SingularType<T>>)
&
	(<T extends ArrayClass>
	(entityType: T, projection: (e: Proxy<SingularType<T>>) => void)
	=> SELECT<SingularType<T>> & Promise<SingularType<T>>)
&
	(<T extends ArrayClass>
	(entityType: T, primaryKey : PK, projection: (e: Proxy<SingularType<T>>) => void)
	=> SELECT<SingularType<T>> & Promise<SingularType<T>>)
// calling with definition
& ((entity: Definition | string, primaryKey? : PK, projection? : (e:any)=>void) => SELECT<any>)
// calling with concrete list
& (<T> (entity: T[], projection? : (e:T)=>void) => SELECT<T> & Promise<T[]>)
& (<T> (entity: T[], primaryKey : PK, projection? : (e:T)=>void) => SELECT<T> & Promise<T>)


export class INSERT<T> extends ConstructedQuery {
	static into  (entity : Definition | string, entries? : object | object[]) : INSERT<any>
	static into <T> (entity:Constructable<T>, entries? : object | object[]) : INSERT<T>
	static into <T> (entity:T, entries? : T | object | object[]) : INSERT<T>
	into  (entity : Definition | string) : this
	data (block : (e:T)=>void) : this
	entries (...entries : object[]) : this
	columns (...col: string[]) : this
	values (... val: any[]) : this
	rows (... row: any[]) : this
	INSERT : CQN.INSERT
}

export class DELETE<T> extends ConstructedQuery {
	static from (entity : Definition | string, primaryKey? : PK) : DELETE<any>
	byKey (primaryKey? : PK) : this
	where (predicate:object) : this
	where (...expr : any[]) : this
	and (predicate:object) : this
	and (...expr : any[]) : this
	DELETE : CQN.DELETE
}

export class UPDATE<T> extends ConstructedQuery {
	static entity (entity : Definition | string, primaryKey? : PK) : UPDATE<any>
	static entity <T> (entity:Constructable<T>, primaryKey? : PK) : UPDATE<T>
	static entity <T> (entity:T, primaryKey? : PK) : UPDATE<T>
	byKey (primaryKey? : PK) : this
	// with (block: (e:T)=>void) : this
	// set (block: (e:T)=>void) : this
	set (data:object) : this
	with (data:object) : this
	where (predicate:object) : this
	where (...expr : any[]) : this
	and (predicate:object) : this
	and (...expr : any[]) : this
	UPDATE : CQN.UPDATE
}

export class CREATE<T> extends ConstructedQuery {
	static entity (entity : Definition | string) : CREATE<any>
	CREATE : CQN.CREATE
}

export class DROP<T> extends ConstructedQuery {
	static entity (entity : Definition | string) : DROP<any>
	DROP : CQN.DROP
}
