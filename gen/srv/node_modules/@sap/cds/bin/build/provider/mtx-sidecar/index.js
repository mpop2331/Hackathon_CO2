const path = require('path')
const fs = require('fs')
const { FOLDER_GEN, DEFAULT_CSN_FILE_NAME } = require('../../constants')
const NodeCfModuleBuilder = require('../nodejs')
const ResourcesTarProvider = require('../mtx/resourcesTarBuilder')
const { INFO, ERROR } = NodeCfModuleBuilder
const { relativePaths, BuildError } = require('../../util')

const DEFAULT_MAIN_FOLDER = "_main"

class MtxSidecarModuleBuilder extends NodeCfModuleBuilder {
    get priority() {
        // should be scheduled after 'hana' build tasks are finished
        return NodeCfModuleBuilder.PRIORITY_MIN_VALUE
    }
    init() {
        super.init()
        if (this.buildOptions.root === this.buildOptions.target) {
            this.task.dest = path.join(this.task.dest, FOLDER_GEN)
        }
    }

    /**
     * Builds the mtx sidecar app consisting of:
     * - nodejs app model defined by the required sidecar services
     * - main app model defined by the build task's model options including feature models and resources TAR
     *
     * build.target=".": 'dest' -> 'model-provider/gen'
     * build.target="gen": 'dest' -> 'gen/model-provider'
     */
    async build() {
        // nodejs app parts have to be built using sidecar env
        const sidecarEnv = this.env.for("cds", this.task.src)
        // build main application
        await this._buildMainApp(sidecarEnv)
        // build node application
        await this._buildNodeApp(sidecarEnv)
    }

    /**
     * Builds the mtx sidecar nodejs app parts.
     * @param {object} sidecarEnv cds env based on the sidecar dir
     */
    async _buildNodeApp(sidecarEnv) {
        const destSidecar = this.task.dest
        const destSidecarSrc = path.join(destSidecar, this.env.folders.srv)
        const model = this._compileSidecarSync(sidecarEnv)
        await this.compileToJson(model, path.join(destSidecarSrc, DEFAULT_CSN_FILE_NAME))
        await this.collectLanguageBundles(model, destSidecarSrc)
        await this._copyProjectRootContent(this.task.src, destSidecar)
    }

    /**
     * Builds the main app parts containing base model CSN with feature CSNs and resources TAR.
     * @param {object} sidecarEnv cds env based on the sidecar dir
     */
    async _buildMainApp(sidecarEnv) {
        if (sidecarEnv.requires['cds.xt.ModelProviderService']?.kind !== 'in-sidecar') {
            throw new Error("Invalid MTX sidecar configuration - \"cds.xt.ModelProviderService\": \"in-sidecar\" missing")
        }
        let main = sidecarEnv.requires['cds.xt.ModelProviderService']?.root
        const profiles = this.env.get("profiles") || []

        if (!profiles.includes("production") && !profiles.includes("prod")) {
            main = DEFAULT_MAIN_FOLDER
            // root should represent the production use case and not development
            this.pushMessage(`Sidecar main application build results are created in folder '${main}'. Enable the 'production' or 'prod' profile if the folder is configured differently.`, INFO)
        }
        const destRoot = this.task.dest
        const destMain = path.join(destRoot, main)
        const destMainSrv = path.join(destMain, this.env.folders.srv)
        const csn = await this.model()
        if (!csn) {
            return
        }
        const { dictionary, sources } = await this.compileAll(csn, destMainSrv, destMain)
        await this.collectAllLanguageBundles(dictionary, sources, destMainSrv, destMain)

        // create resources TAR
        // resources are determined based on available database build task, SQLite as fallback
        await new ResourcesTarProvider(this).createTar(destMain, csn)

        // copy package.json and .cdsrc.json from project root
        await this._copyMainConfigFiles(this.cds.root, destMain)
    }

    /**
     * Synchronous compilation using the sidecar context.
     * @param {object} sidecarEnv cds env based on the sidecar dir
     * @returns the compiled mtx sidecar CSN
     */
    _compileSidecarSync(sidecarEnv) {
        const env = this.env
        try {
            this.cds.root = this.task.src
            this.cds.env = sidecarEnv
            const modelPaths = this.cds.resolve('*', false)
            const modelFilePaths = this.cds.resolve(modelPaths)

            if (!modelFilePaths || modelFilePaths.length === 0) {
                throw new BuildError("No model found for MTX sidecar app")
            }
            // candidate for strict mode support
            // entries for @sap/** model paths are missing if the module hasn't been installed, e.g. @sap/cds-mtxs
            const missingModels = modelPaths.filter(p => {
                if (p.startsWith('@sap/')) {
                    const files = this.cds.resolve(p)
                    return !files || files.length === 0
                }
            })
            if (missingModels.length > 0) {
                this.pushMessage(`Some model paths could not be resolved. Make sure the npm modules have been installed: ${missingModels.join(', ')}`, ERROR)
            }
            this._logger._debug && this._logger.debug(`sidecar model: ${relativePaths(this.buildOptions.root, modelFilePaths).join(", ")}`)

            // synchronous compilation
            return this.cds.load(modelFilePaths, { sync: true, ...this.options() })
        } finally {
            // restore project scope
            this.cds.root = this.buildOptions.root
            this.cds.env = env
        }
    }

    async _copyMainConfigFiles(src, dest) {
        const packageJson = path.join(src, 'package.json')
        const cdsrcJson = path.join(src, '.cdsrc.json')
        const promises = []
        if (fs.existsSync(packageJson)) {
            promises.push(this.copy(packageJson).to(path.join(dest, 'package.json')))
        }
        if (fs.existsSync(cdsrcJson)) {
            promises.push(this.copy(cdsrcJson).to(path.join(dest, '.cdsrc.json')))
        }
        return promises
    }
}
module.exports = MtxSidecarModuleBuilder
