const path = require('path')
const fs = require('fs')
const BuildTaskEngine = require('./buildTaskEngine')
const BuildTaskFactory = require('./buildTaskFactory')
const BuildTaskHandler = require('./buildTaskHandler')
const { LOG_MODULE_NAMES } = require('./constants')
const { BuildError } = require('./util')

module.exports = Object.assign(build,
    { build, BuildTaskFactory, BuildTaskEngine, BuildTaskHandler, BuildError }
)

/**
 * New modular build.
 *
 * @param {object} options - commmand options as defined by build command.
 */
async function build(options = {}) {
    const projectPath = path.resolve(options.project || '.')

    if (!fs.lstatSync(projectPath).isDirectory()) {
        return Promise.reject(`Project [${projectPath}] does not exist`)
    }

    const cds = require('./cds')
    if (projectPath !== process.cwd()) {
        const env = cds.env.for('cds', projectPath);
        cds.env = env
        cds.root = projectPath
    }
    const logger = options.logger || cds.log(LOG_MODULE_NAMES)

    const buildOptions = _mergeCliOptions({ root: projectPath }, options)

    let tasks = await new BuildTaskFactory(logger).getTasks(buildOptions)
    return new BuildTaskEngine(logger).processTasks(tasks, buildOptions)
}

function _mergeCliOptions(buildOptions, options) {
    buildOptions["log-level"] = options["log-level"]
    buildOptions.cli = options.cli
    buildOptions.cmdOptions = options
    return buildOptions
}
