const { URL } = require('url')
const cds = require('../../../lib')
const LOG = cds.log()

module.exports = {
  async token(request, response) {
    if (request.method === 'HEAD') {
      response.status(204).send()
      return
    }

    const { passcode, refresh_token, subdomain, clientid, clientsecret } = request.query
    const { credentials } = cds.env.requires.auth
    if (!credentials) {
      cds.error(
        'No auth credentials defined. The application is likely not bound to an authentication service instance.'
      )
    }

    const parsedUrl = new URL(credentials.url)
    parsedUrl.hostname = subdomain + '.' + parsedUrl.hostname.split('.').slice(1).join('.')

    LOG.info(`Get auth token using URL ${parsedUrl}`)

    if (clientid) {
      LOG.info(`Using clientid/clientsecret from API call with clientid ${clientid}`)
    }

    const username = clientid ? clientid : credentials.clientid
    const password = clientid ? clientsecret : credentials.clientsecret
    const { xsappname } = cds.env.requires.auth?.credentials ?? cds.env.requires.uaa?.credentials ?? {}
    const path =
      (refresh_token
        ? `oauth/token?grant_type=refresh_token&refresh_token=${refresh_token}`
        : `oauth/token?grant_type=password&passcode=${encodeURIComponent(passcode)}`) +
      `&scope=${encodeURIComponent(xsappname + '.cds.ExtensionDeveloper')}`

    try {
      const { data } = await require('axios').post(
        parsedUrl + path,
        { 'Content-Type': 'application/json' },
        { auth: { username, password } }
      )
      response.send(data)
    } catch (error) {
      const rootCause = error.response?.data ? JSON.stringify(error.response?.data) : error.message
      error.message = `Authentication failed with root cause '${rootCause}'. Passcode URL: https://${parsedUrl.hostname}/passcode`
      const {
        constructor: { name },
        message
      } = error
      const status = name in { JwtRequestError: 1, IncompleteJwtResponseError: 1 } ? 401 : error.response.status ?? 500
      LOG.error(message)
      response.status(status).send({ message, status })
    }
  }
}
