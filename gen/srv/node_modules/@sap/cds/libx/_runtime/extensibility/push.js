const fs = require('fs')
const path = require('path')
const cds = require('../cds')

const activate = require('./activate')
const { collectFiles, getCompilerError } = require('./utils')
const { packTarArchive, unpackTarArchive } = require('../../../lib/utils/resources')
const linter = require('./linter')

const TEMP_DIR = fs.realpathSync(require('os').tmpdir())
const LOG = cds.log('mtx')

const _compileProject = async function (extension, req) {
  let csn, root, files
  try {
    root = await fs.promises.mkdtemp(`${TEMP_DIR}${path.sep}extension-`)
    await unpackTarArchive(extension, root)
    files = collectFiles(root, ['.cds', '.csn']) // REVISIT: don't we have exactly one ext.csn file for all extensions?
    csn = await cds.compile(files, { flavor: 'parsed' })
    if (csn.requires) delete csn.requires
  } catch (err) {
    if (err.messages) req.reject(400, getCompilerError(err.messages))
    else throw err
  } finally {
    fs.promises.rm(root, { recursive: true, force: true }).catch(() => {})
  }

  return { csn, files }
}

const base = async function (req) {
  const cdsFiles = cds.resolve('*').filter(f => f.startsWith(cds.root) && !f.includes('node_modules'))
  const csvObj = await cds.deploy.resources()
  const csvFiles = Object.keys(csvObj).filter(f => f.startsWith(cds.root) && !f.includes('node_modules'))
  const i18nFiles = collectFiles(cds.root, ['.properties'])
  if (req._.res) req._.res.set('content-type', 'application/octet-stream; charset=binary')

  return packTarArchive([...cdsFiles, ...csvFiles, ...i18nFiles], cds.root)
}

// const _copyFile = async function (file, dir) {
//   const destination = path.join(dir, path.relative(cds.root, file))
//   const dirname = path.dirname(destination)
//   if (!(await exists(dirname))) await fs.promises.mkdir(dirname, { recursive: true })
//   await fs.promises.copyFile(file, destination)
// }

const pull = async function (req) {
  LOG.info(`pulling latest model for tenant '${req.tenant}'`)
  const { 'cds.xt.ModelProviderService': mps } = cds.services
  const csn = await mps.getCsn({
    tenant: req.tenant,
    toggles: Object.keys(cds.context.features || {}), // with all enabled feature extensions
    base: true, // without any custom extensions
    flavor: 'xtended'
  })
  // const csvObj = await cds.deploy.resources()
  // const csvFiles = Object.keys(csvObj).filter(f => f.startsWith(cds.root) && !f.includes('node_modules'))
  // const i18nFiles = collectFiles(cds.root, ['.properties'])

  req._.res?.set('content-type', 'application/octet-stream; charset=binary')

  let temp, tgz
  try {
    temp = await fs.promises.mkdtemp(`${TEMP_DIR}${path.sep}extension-`)
    await fs.promises.writeFile(path.join(temp, 'index.csn'), cds.compile.to.json(csn))
    // for (const file of csvFiles) await _copyFile(file, temp)
    // for (const file of i18nFiles) await _copyFile(file, temp)
    tgz = await packTarArchive(temp)
  } finally {
    fs.promises.rm(temp, { recursive: true, force: true }).catch(() => {})
  }

  return tgz
}

const push = async function (req) {
  let { extension, tag } = req.data
  if (!extension) req.reject(400, 'Missing extension')
  const sources = typeof extension === 'string' ? Buffer.from(extension, 'base64') : extension
  const { csn: extCsn, files } = await _compileProject(sources, req)
  if (!extCsn) req.reject(400, 'Missing or bad extension')
  if (!tag) tag = null
  const tenant = req.tenant
  if (tenant) cds.context = { tenant }

  // remove current extension with tag
  if (tag) {
    await DELETE.from('cds.xt.Extensions').where({ tag })
  }

  LOG.info(`validating extension '${tag}' ...`)
  // validation
  const { 'cds.xt.ModelProviderService': mps } = cds.services
  // REVISIT: Isn't that also done during activate?
  const csn = await mps.getCsn(tenant, Object.keys(cds.context.features || {}))
  try {
    cds.extend(csn).with(extCsn)
  } catch (err) {
    return req.reject(400, getCompilerError(err.messages))
  }
  await linter(extCsn, csn, files, req)

  // insert and activate extension
  const ID = cds.utils.uuid()
  await INSERT.into('cds.xt.Extensions').entries({
    ID,
    csn: JSON.stringify(extCsn),
    sources,
    activated: 'database',
    tag
  })

  LOG.info(`activating extension '${tag}' ...`)
  await activate(ID, null, tenant)
}

module.exports = { base, push, pull }
