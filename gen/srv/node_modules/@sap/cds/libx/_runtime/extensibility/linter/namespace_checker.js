const Checker = require('./checker_base')

class NamespaceChecker extends Checker {
  static async check(extensionCsn, fullCsn, compileDir, mtxConfig) {
    let elementPrefixes = mtxConfig['element-prefix']
    let namespaceBlocklist = mtxConfig['namespace-blocklist'] || mtxConfig['namespace-blacklist']
    const warnings = []

    if (elementPrefixes) {
      if (!Array.isArray(elementPrefixes)) {
        elementPrefixes = [elementPrefixes]
      }

      if (extensionCsn.extensions) {
        // forall switches back to definitions if extensions are undefined
        extensionCsn.forall(
          () => true,
          (element, name, parent) => {
            element.name = name // TODO check if bug
            this._checkElement(element, parent, elementPrefixes, compileDir, warnings)
          },
          extensionCsn.extensions
        )
      }

      extensionCsn.forall(
        element => {
          return ['entity', 'function', 'action'].includes(element.kind)
        },
        entity => {
          this._checkEntity(entity, extensionCsn, fullCsn, elementPrefixes, compileDir, warnings)
        }
      )
    }

    if (namespaceBlocklist) {
      if (!Array.isArray(namespaceBlocklist)) {
        namespaceBlocklist = [namespaceBlocklist]
      }

      extensionCsn.forall('service', service => {
        this._checkNamespace(service, namespaceBlocklist, compileDir, warnings)
      })

      extensionCsn.forall(
        element => {
          return ['aspect', 'entity', 'type'].includes(element.kind)
        },
        entity => {
          if (entity._unresolved) return // skip unresolved entities
          this._checkNamespace(entity, namespaceBlocklist, compileDir, warnings)
        }
      )
    }

    return warnings
  }

  static _checkElement(element, parent, elementPrefixes, compileDir, warnings) {
    if (elementPrefixes.length < 1) {
      return
    }

    if (!parent) {
      return
    }

    for (const elementPrefix of elementPrefixes) {
      if (!parent.extend || element.name.startsWith(elementPrefix)) {
        return
      }
    }

    warnings.push(this._createPrefixWarning(element, compileDir, elementPrefixes))
  }

  static _checkEntity(element, reflectedCsn, reflectedFullCsn, elementPrefixes, compileDir, warnings) {
    if (elementPrefixes.length < 1) {
      return
    }

    if (!this._hasEnclosingEntity(reflectedCsn, element)) {
      return
    }

    const parent = this._getEnclosingEntity(reflectedCsn, element)

    // parent exists in extension
    if (parent) {
      return
    }

    // check full csn for parent - if it exists, continue
    const parentFromFullCsn = this._getEnclosingEntity(reflectedFullCsn, element)
    if (!parentFromFullCsn) {
      return
    }

    // checks nested element - TODO determine real parent and split off parent name
    const nestedElementName = this._getNestedEntityName(element) // ,parent

    for (const elementPrefix of elementPrefixes) {
      if (nestedElementName.startsWith(elementPrefix)) {
        return
      }
    }

    warnings.push(this._createPrefixWarning(element, compileDir, elementPrefixes))
  }

  static _hasEnclosingEntity(reflectedCsn, element) {
    const plainEntityName = element.name.replace(reflectedCsn.namespace + '.', '')
    const splitEntityName = plainEntityName.split('.')
    if (splitEntityName.length > 1) {
      return true
    }
    return false
  }

  static _getEnclosingEntity(reflectedCsn, element) {
    const splitEntityName = element.name.split('.')
    if (splitEntityName.length > 1) {
      splitEntityName.pop()
      return reflectedCsn.definitions[splitEntityName.join('.')]
    }
    return null
  }

  static _getNestedEntityName(element) {
    const splitEntityName = element.name.split('.')
    splitEntityName.shift()
    return splitEntityName.join('.')
  }

  static _checkNamespace(element, namespaceBlacklist, compileDir, warnings) {
    for (const namespace of namespaceBlacklist) {
      if (element.name.startsWith(namespace)) {
        warnings.push(this._createNamespaceWarning(element, compileDir, namespace))
      }
    }
  }

  static _createPrefixWarning(element, compileDir, prefixRule) {
    const originFile = this._localizeFile(element.$location.file, compileDir)

    return (
      'Element ' +
      element.name +
      ' from ' +
      originFile +
      ' (line:' +
      element.$location.line +
      ', col:' +
      element.$location.col +
      ')' +
      ' does not adhere to prefix rule: ' +
      prefixRule
    )
  }

  static _createNamespaceWarning(element, compileDir, namespace) {
    const originFile = this._localizeFile(element.$location.file, compileDir)

    return (
      'Element ' +
      element.name +
      ' from ' +
      originFile +
      ' (line:' +
      element.$location.line +
      ', col:' +
      element.$location.col +
      ')' +
      ' uses a forbidden namespace: ' +
      namespace
    )
  }
}

module.exports = NamespaceChecker
